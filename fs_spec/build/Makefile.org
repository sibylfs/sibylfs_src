#+TITLE: Sibylfs makefile
#+AUTHOR: Tom Ridge
#+OPTIONS: title:true 

# ignore #PROPERTY: header-args :tangle Makefile :exports code 

To tangle this file, call org-tangle-file with a filename, eg

#+BEGIN_SRC emacs-lisp
(defun my-tangle () 
  (interactive)
  (org-babel-tangle-file "Makefile.org" "Makefile" "makefile"))

(define-key my-keys-minor-mode-map (kbd "M-t M-b M-t") 'my-tangle) ; for quick access
#+END_SRC

* Introduction

The stages are:

  * preprocess `.lem_cppo` files to get `.lem` 
  * run lem; resulting files of the form `t_xxx.ml`
  * rename all `t_xxx.ml` to `xxx.ml`
  * compile the resulting `.ml` and `.mli` files


#+BEGIN_EXAMPLE
# Lem build process
#
# t_xxx.lem_cppo
#  |  generated_lem
#  \/
# t_xxx.lem ---------------+-----------------------+
#  |  generated_tml       |  lem_hol              |  lem_isa
#  \/                      \/                      \/
# t_xxx.ml                 t_xxxScript.sml         T_xxx.thy
#  |  generated_ml
#  \/
# xxx.ml
#  |
#  \/
# 
# Other build commands: lem_hol_copy, lem_isa_copy

#+END_EXAMPLE

* Check env vars

Before we do anything, we check that env vars are defined.

#+BEGIN_SRC makefile

# WARNING! WARNING! WARNING!
# This file is generated from Makefile.org using emacs, org, babel, tangle
# WARNING! WARNING! WARNING!

# http://stackoverflow.com/questions/20389064/using-gnu-make-functions-to-check-if-variables-are-defined
check-var-defined = $(if $(1),,$(error $(1) is not defined))

-include ../../config.sh # we may be using env vars instead of a config.sh

$(call check-var-defined,SIBYLFS_CONFIG)
# ifndef SIBYLFS_CONFIG
# $(error SIBYLFS_CONFIG is not defined; check ../../config.sh)
# else
# endif

# do we want to be very cautious? let's just check LEMPATH as well
# ifndef LEM
# $(error)
# else
# endif

$(call check-var-defined,LEM)
$(call check-var-defined,LEMLIB)
$(call check-var-defined,EXTRACTDIR)
$(call check-var-defined,CPPO)

#+END_SRC

* Variables

Now we declare some variables.

#+BEGIN_SRC makefile
BISECT?= # or "-package bisect" to build with bisect
  OCAMLC:=ocamlfind ocamlc $(BISECT)   #
OCAMLOPT:=ocamlfind ocamlopt $(BISECT) #
WARNINGS:=-w -26-8
# COMPFLAGS:=$(WARNINGS) -package sexplib,sexplib.syntax # might as well

# LEM:= from env
LEMFLAGS:=-lib $(LEMLIB) -only_changed_output -wl_unused_vars ign -wl_rename err
EXTRACTCMA:=$(EXTRACTDIR)/extract.cma
EXTRACTCMXA:=$(EXTRACTDIR)/extract.cmxa

OCAMLC_ARGS:=-I $(EXTRACTDIR) extract.cma -package sexplib,sexplib.syntax,sha $(WARNINGS) -c 
OCAMLOPT_ARGS:=$(OCAMLC_ARGS:.cma=.cmxa)

#+END_SRC

* More variables: files

The files we are dealing with.

#+BEGIN_SRC makefile
DOTCPPO:=\
t_fs_spec.lem_cppo \
t_fs_spec_fs_command_properties.lem_cppo \
t_fs_spec_properties_perms.lem_cppo \
t_dir_heap.lem_cppo


GENERATED_LEM:=$(patsubst %.lem_cppo,%.lem,$(DOTCPPO))

DOTLEM:=\
t_list_array.lem \
t_fs_prelude.lem \
t_fs_spec_properties.lem \
$(GENERATED_LEM)

DOTMLI:=abstract_string.mli \
fs_dict_wrappers.mli        \
fs_interface.mli            \
fs_prelude.mli              \
lem_support.mli             \
list_array.mli

GENERATED_TML:=$(patsubst %.lem,%.ml,$(DOTLEM)) 

GENERATED_ML:=$(patsubst t_%.ml,%.ml,$(GENERATED_TML))

DOTML:=\
abstract_string.ml      \
lem_support.ml          \
fs_prelude.ml           \
list_array.ml           \
fs_spec.ml              \
dir_heap.ml             \
fs_dict_wrappers.ml     \
fs_printer.ml           \
fs_dump.ml              \
fs_interface.ml         


CMO:=$(DOTML:.ml=.cmo)
#+END_SRC

* target: all

#+BEGIN_SRC makefile
# this makefile is phased: the following phases must be run in order;
# it should be possible to type: `make before_all`, and then to make
# any of the subsequent targets e.g. `make compile`
all: 
	$(MAKE) before_all 
	$(MAKE) generated_lem
	$(MAKE) generated_tml
	$(MAKE) generated_ml
	$(MAKE) compile
	$(MAKE) generated.tar # in case I forget to update it
#+END_SRC

* target: before_all

This links the files in `../src` into this build directory.

#+BEGIN_SRC makefile
# need these present before we do anything
before_all: $(EXTRACTCMA) $(EXTRACTCMXA) link
.PHONY: before_all

link: 
	ln -sf ../src/* .
	touch $@
#+END_SRC

* Run cppo (target: generated_lem)

#+BEGIN_SRC makefile

# currently switch manually between the versions 
# TODO: add some more comfort
# -D xxx include something
# -U xxx exclude something
# -n don't output source annotations
# by default all aspects are present, if you want to turn them off,
# use command line argument 'CPPO_ARGS="xxxx"'

ifndef CPPO_ARGS
CPPO_ARGS:=-D aspect_perms
endif

$(GENERATED_LEM): %.lem: %.lem_cppo
	if [ -f $*.lem ]; then chmod ugo+w $*.lem; fi
	$(CPPO) $(CPPO_ARGS) $*.lem_cppo -o $*.lem
	chmod ugo-w $*.lem

# don't use this in rules - just for triggering build of generated lem files
generated_lem: $(GENERATED_LEM)
	touch $@
#+END_SRC

* Run lem (target: generated_tml; files of form t_xxx.ml)

Lem runs in a single pass, generating multiple files. This is a bit
tricky for make.

#+BEGIN_SRC makefile
run_lem: $(DOTLEM)
	echo building for $@
	$(LEM) $(LEMFLAGS) -ocaml $(DOTLEM)
	cp t_fs_spec.ml t_fs_spec.ml.tmp
	sed -f patch_lem.sed t_fs_spec.ml.tmp > t_fs_spec.ml
	rm t_fs_spec.ml.tmp
	touch $@

# make the t_ml files depend on actually running lem; lem processes all files at once
$(GENERATED_TML): run_lem

generated_tml: $(GENERATED_TML)
	touch $@
#+END_SRC

* Rename t_xxx.ml to xxx.ml (target: generated_ml)

#+BEGIN_SRC makefile

# the following sets up a dependency known to make, between t_*.ml and *.ml
$(GENERATED_ML): %.ml: t_%.ml
	if [ -f $@ ]; then chmod ugo+w $@; fi
	cp $< $@.tmp
	sed -f patch_gen_ml.sed $@.tmp >$@
	rm -f $@.tmp
	chmod ugo-w $@

# don't use this in rules - just for triggering build of generated ml files
generated_ml: $(GENERATED_ML)
	touch $@

#+END_SRC

* Dependencies (dot format)

camlp4o is slow; ocamldep is slow with camlp4o; rather than track
dependencies etc, we record the dependencies as:

#+BEGIN_SRC dot :file /tmp/tmp.png :exports results
digraph {
abstract_string -> {  }
dir_heap -> { fs_spec list_array fs_prelude lem_support }
fs_dict_wrappers -> { fs_prelude lem_support }
fs_dump -> { dir_heap list_array fs_spec fs_dict_wrappers }
fs_interface -> { fs_dump dir_heap fs_printer fs_spec abstract_string lem_support }
fs_prelude -> { lem_support }
fs_printer -> { list_array fs_spec fs_dict_wrappers lem_support }
fs_spec -> { list_array abstract_string fs_prelude lem_support }
lem_support -> {  }
list_array -> { abstract_string }

}
#+END_SRC

#+RESULTS:
[[file:/tmp/tmp.png]]

* Dependencies (make format) and extra compile flags

#+BEGIN_SRC makefile
DEPS_abstract_string=
DEPS_lem_support=
DEPS_list_array=abstract_string.cmi
DEPS_fs_prelude=lem_support.cmi
DEPS_fs_dict_wrappers=fs_prelude.cmi lem_support.cmi
DEPS_fs_spec=list_array.cmi abstract_string.cmi fs_prelude.cmi lem_support.cmi
DEPS_dir_heap=fs_spec.cmi list_array.cmi fs_prelude.cmi lem_support.cmi
DEPS_fs_dump=dir_heap.cmi list_array.cmi fs_spec.cmi fs_dict_wrappers.cmi
DEPS_fs_printer=list_array.cmi fs_spec.cmi fs_dict_wrappers.cmi lem_support.cmi
DEPS_fs_interface=fs_dump.cmi dir_heap.cmi fs_printer.cmi fs_spec.cmi abstract_string.cmi lem_support.cmi

# add camlp4o only for those .ml files (and .mli interfaces) that need it
camlp4o=-syntax camlp4o
EXTRA_abstract_string.ml=$(camlp4o)
EXTRA_fs_spec.ml=$(camlp4o)
EXTRA_dir_heap.ml=$(camlp4o)
EXTRA_fs_dump.ml=$(camlp4o)
EXTRA_fs_printer.ml=$(camlp4o)
EXTRA_fs_interface.ml=$(camlp4o)
#+END_SRC

* Generic rules

#+BEGIN_SRC makefile

# cm[ox] depend on cmi; had to move these to associated rules
# %.cmo: %.cmi
# %.cmx: %.cmi

# make invocations of commands slightly more succinct by exporting to
# bash env
export OCAMLC_ARGS export OCAMLOPT_ARGS

# cmo depends on ml 
# FIXME is the following supported? it is
%.cmo: %.ml %.cmi 
	$(OCAMLC) $$OCAMLC_ARGS   $(EXTRA_$*.ml) $*.ml

%.cmx: %.ml %.cmi
	$(OCAMLOPT) $$OCAMLOPT_ARGS $(EXTRA_$*.ml) $*.ml

# cmi depends on mli and dependent cmi; for dependent cmi we resort to
# macros :(  won't work $(DEPS_$*)
%.cmi: %.mli 
	$(OCAMLOPT) $$OCAMLOPT_ARGS $(EXTRA_$*.ml) $*.mli

# FIXME following is ugly (see below for link)
define cmi_rules
$(1).cmi: $(DEPS_$(1))
endef

$(foreach i,$(CMO:.cmo=),$(eval $(call cmi_rules,$(i))))

#+END_SRC

* Building missing mli files for the project

We only want to generate particular mli files; this is specific to the
project.

#+BEGIN_SRC makefile
# mli files we need to create (others exist already)
MISSING_MLI:=dir_heap.mli fs_dump.mli fs_printer.mli fs_spec.mli

# FIXME following is ugly

# http://stackoverflow.com/questions/9691508/how-can-i-use-macros-to-generate-multiple-makefile-targets-rules-inside-foreach

# the following macro allows to produce deps like: fs_spec.mli:
# $(DEPS_fs_spec)
define missing_mli_rules
$(1).mli: $(DEPS_$(1))

$(1).mli: $(1).ml
#	$(OCAMLC) $(OCAMLC_ARGS) $(EXTRA_$(1).ml) -i $(1).ml > $(1).mli
	$(OCAMLC) $$$$OCAMLC_ARGS $(EXTRA_$(1).ml) -i $(1).ml > $(1).mli # NB horrible $ escaping
endef

# restrict to particular targets
$(foreach i,$(MISSING_MLI:.mli=),$(eval $(call missing_mli_rules,$(i))))


#+END_SRC

* Actually do the compile (target: compile)

#+BEGIN_SRC makefile
compile: $(CMO:.cmo=.cmi) $(CMO) $(CMO:.cmo=.cmx) fs_spec_lib.cma fs_spec_lib.cmxa

# -g flag turns on debugging info (e.g. for stacktrace)
fs_spec_lib.cma: $(CMO)
	$(OCAMLC)   -g -a -o $@ $(CMO)

fs_spec_lib.cmxa: $(CMO:.cmo=.cmx)
	$(OCAMLOPT) -g -a -o $@ $(CMO:.cmo=.cmx)
#+END_SRC

* Interface only

The interface files have reduced dependencies. Thus, it is possible to
build fs_interface.cmi very simply.

#+BEGIN_SRC makefile
interface_only: generated_ml
	$(OCAMLC) $$OCAMLC_ARGS -syntax camlp4o -c abstract_string.mli -c lem_support.mli fs_interface.mli
	touch $@
#+END_SRC

* Tarball of generated files (to avoid invoking lem and cppo)

The order matters: we want lem before t_xxx.ml before .ml so that,
when unpacking, make doesn't think that eg a .lem is newer than the
corresponding .ml

Note that we still need lem installed so that we can access
extract.cm[x]a.

#+BEGIN_SRC makefile

define generated_files

t_fs_spec_fs_command_properties.lem
t_dir_heap.lem
t_fs_spec.lem
t_fs_spec_properties_perms.lem

t_dir_heap.ml
t_fs_prelude.ml
t_fs_spec_fs_command_properties.ml
t_fs_spec.ml
t_fs_spec_properties.ml
t_fs_spec_properties_perms.ml
t_list_arrayAuxiliary.ml
t_list_array.ml

dir_heap.ml
fs_prelude.ml
fs_spec_fs_command_properties.ml
fs_spec.ml
fs_spec_properties.ml
fs_spec_properties_perms.ml
list_array.ml

endef

generated.tar: generated_ml
	$(file >files_in_tar,$(generated_files))
	tar cvf $@  --files-from files_in_tar

generated: FORCE
	tar --touch -xvf generated.tar

#+END_SRC

* FIXME a target to build the dot file

* Clean

#+BEGIN_SRC makefile
# FIXME tidy this
# NB don't delete generated.tar - this is part of the "source" and should be upto date

clean_ocaml:
	rm -f *.cm[iox] *.a *.o *.cma *.cmxa dir_heap.mli fs_dump.mli fs_printer.mli fs_spec.mli

clean: FORCE
	rm -f $(GENERATED_LEM) $(GENERATED_TML) $(GENERATED_ML)
	rm -f *.cm[iox] *.a *.o *.cma *.cmxa dir_heap.mli fs_dump.mli fs_printer.mli fs_spec.mli
	rm -f link generated_lem run_lem generated_tml generated_ml cmo cmx interface_only files_in_tar
	find . -maxdepth 1 -type l -exec rm \{\} \;	
	rm -f depend.{dot,pdf} .depend.min
	rm -f $(patsubst %.lem, %Auxiliary.lem, $(DOTLEM))
	rm -f $(patsubst %.lem, %Auxiliary.ml, $(DOTLEM))
	rm -f $(patsubst %.lem, %Auxiliary.byte, $(DOTLEM))
	rm -f $(patsubst %.lem, %.html, $(DOTLEM))
	rm -f $(patsubst %.lem, %ml.md, $(DOTLEM))
	rm -f $(patsubst %.lem, %.md, $(DOTLEM))
	rm -f *Script.sml
	rm -f a.out
	rm -rf ocamldoc ocamldoc* depend.svg fs_spec.html fs_spec.ml.md # t_fs_spec.lem_cppo.{html,md}
	rm -f *.tmp

FORCE:

#+END_SRC

* Emacs local variables

Local variables:
indent-tabs-mode: 't
org-src-preserve-indentation: 't
End:
