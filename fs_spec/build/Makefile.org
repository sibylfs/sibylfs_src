#+TITLE: Sibylfs makefile
#+AUTHOR: Tom Ridge
#+OPTIONS: title:true 

# ignore #PROPERTY: header-args :tangle Makefile :exports code 

To tangle this file, call org-tangle-file with a filename, eg

#+BEGIN_SRC emacs-lisp
(org-babel-tangle-file "Makefile.org" "Makefile" "makefile")
#+END_SRC

* Introduction

The stages are:

  * preprocess `.lem_cppo` files to get `.lem` 
  * run lem; resulting files of the form `t_xxx.ml`
  * rename all `t_xxx.ml` to `xxx.ml`
  * compile the resulting `.ml` and `.mli` files


#+BEGIN_EXAMPLE
# Lem build process
#
# t_xxx.lem_cppo
#  |  generated_lem
#  \/
# t_xxx.lem ---------------+-----------------------+
#  |  generated_tml       |  lem_hol              |  lem_isa
#  \/                      \/                      \/
# t_xxx.ml                 t_xxxScript.sml         T_xxx.thy
#  |  generated_ml
#  \/
# xxx.ml
#  |
#  \/
# 
# Other build commands: lem_hol_copy, lem_isa_copy

#+END_EXAMPLE

* Check env vars

Before we do anything, we check that env vars are defined.

#+BEGIN_SRC makefile

# WARNING! WARNING! WARNING!
# This file is generated from Makefile.org using emacs, org, babel, tangle
# WARNING! WARNING! WARNING!


-include ../../config.sh # we may be using env vars instead of a config.sh
ifndef SIBYLFS_CONFIG
$(error SIBYLFS_CONFIG is not defined; check ../../config.sh)
else
endif

# do we want to be very cautious? let's just check LEMPATH as well
ifndef LEMPATH
$(error)
else
endif

#+END_SRC

* Variables

Now we declare some variables.

#+BEGIN_SRC makefile
BISECT?= # or "-package bisect" to build with bisect
CAMLC:=ocamlfind ocamlc $(BISECT)
CAMLOPT:=ocamlfind ocamlopt $(BISECT)
WARNINGS:=-w -26-8
COMPFLAGS:=$(WARNINGS) -package sexplib,sexplib.syntax # might as well

LEM:=$(LEMPATH)
LEMFLAGS:=-only_changed_output -wl_unused_vars ign -wl_rename err
EXTRACTCMA:=$(EXTRACTDIR)/extract.cma
EXTRACTCMXA:=$(EXTRACTDIR)/extract.cmxa

CAMLCINCLUDES:=-I $(EXTRACTDIR) extract.cma
CAMLOPTINCLUDES:=$(CAMLCINCLUDES:.cma=.cmxa)
#+END_SRC

* More variables: files

The files we are dealing with.

#+BEGIN_SRC makefile
DOTCPPO:=\
t_fs_spec.lem_cppo \
t_fs_spec_fs_command_properties.lem_cppo \
t_fs_spec_properties_perms.lem_cppo \
t_dir_heap.lem_cppo


GENERATED_LEM:=$(patsubst %.lem_cppo,%.lem,$(DOTCPPO))

DOTLEM:=\
t_list_array.lem \
t_fs_prelude.lem \
t_fs_spec_properties.lem \
$(GENERATED_LEM)

DOTMLI:=abstract_string.mli \
fs_dict_wrappers.mli        \
fs_interface.mli            \
fs_prelude.mli              \
lem_support.mli             \
list_array.mli

GENERATED_TML:=$(patsubst %.lem,%.ml,$(DOTLEM)) 

GENERATED_ML:=$(patsubst t_%.ml,%.ml,$(GENERATED_TML))

DOTML:=\
abstract_string.ml      \
lem_support.ml          \
fs_prelude.ml           \
list_array.ml           \
fs_spec.ml              \
dir_heap.ml             \
fs_dict_wrappers.ml     \
fs_printer.ml           \
fs_dump.ml              \
fs_interface.ml         


CMO:=$(DOTML:.ml=.cmo)
#+END_SRC

* target: all

#+BEGIN_SRC makefile
# this makefile is phased: the following phases must be run in order;
# it should be possible to type: `make before_all`, and then to make
# any of the subsequent targets e.g. `make compile`
all: 
	$(MAKE) before_all 
	$(MAKE) generated_lem
	$(MAKE) generated_tml
	$(MAKE) generated_ml
	$(MAKE) compile
	$(MAKE) generated.tar # in case I forget to update it
#+END_SRC

* target: before_all

This links the files in `../src` into this build directory.

#+BEGIN_SRC makefile
# need these present before we do anything
before_all: $(EXTRACTCMA) $(EXTRACTCMXA) link
.PHONY: before_all

link: 
	ln -sf ../src/* .
	touch $@
#+END_SRC

* Run cppo (target: generated_lem)

#+BEGIN_SRC makefile

# currently switch manually between the versions 
# TODO: add some more comfort
# -D xxx include something
# -U xxx exclude something
# -n don't output source annotations
# by default all aspects are present, if you want to turn them off,
# use command line argument 'CPPO_ARGS="xxxx"'

ifndef CPPO_ARGS
CPPO_ARGS:=-D aspect_perms
endif

$(GENERATED_LEM): %.lem: %.lem_cppo
	if [ -f $*.lem ]; then chmod ugo+w $*.lem; fi
	$(CPPO) $(CPPO_ARGS) $*.lem_cppo -o $*.lem
	chmod ugo-w $*.lem

# don't use this in rules - just for triggering build of generated lem files
generated_lem: $(GENERATED_LEM)
	touch $@
#+END_SRC

* Run lem (target: generated_tml; files of form t_xxx.ml)

Lem runs in a single pass, generating multiple files. This is a bit
tricky for make.

#+BEGIN_SRC makefile
run_lem: $(DOTLEM)
	echo building for $@
	$(LEM) $(LEMFLAGS) -ocaml $(DOTLEM)
	cp t_fs_spec.ml t_fs_spec.ml.tmp
	sed -f patch_lem.sed t_fs_spec.ml.tmp > t_fs_spec.ml
	rm t_fs_spec.ml.tmp
	touch $@

# make the t_ml files depend on actually running lem; lem processes all files at once
$(GENERATED_TML): run_lem

generated_tml: $(GENERATED_TML)
	touch $@
#+END_SRC

* Rename t_xxx.ml to xxx.ml (target: generated_ml)

#+BEGIN_SRC makefile

# the following sets up a dependency known to make, between t_*.ml and *.ml
$(GENERATED_ML): %.ml: t_%.ml
	if [ -f $@ ]; then chmod ugo+w $@; fi
	cp $< $@.tmp
	sed -f patch_gen_ml.sed $@.tmp >$@
	rm -f $@.tmp
	chmod ugo-w $@

# don't use this in rules - just for triggering build of generated ml files
generated_ml: $(GENERATED_ML)
	touch $@

#+END_SRC

* Dependencies (dot format)

camlp4o is slow; ocamldep is slow with camlp4o; rather than track
dependencies etc, we record the dependencies as:

#+BEGIN_SRC dot :file /tmp/tmp.png :exports results
digraph {
 list_array -> abstract_string
fs_prelude -> lem_support
fs_dict_wrappers -> fs_prelude
fs_dict_wrappers -> lem_support
fs_spec -> list_array
fs_spec -> abstract_string
fs_spec -> fs_prelude
fs_spec -> lem_support
dir_heap -> fs_spec
dir_heap -> list_array
dir_heap -> fs_prelude
dir_heap -> lem_support
fs_dump -> dir_heap
fs_dump -> list_array
fs_dump -> fs_spec
fs_dump -> fs_dict_wrappers
fs_printer -> list_array
fs_printer -> fs_spec
fs_printer -> fs_dict_wrappers
fs_printer -> lem_support
fs_interface -> fs_dump
fs_interface -> dir_heap
fs_interface -> fs_printer
fs_interface -> fs_spec
fs_interface -> abstract_string
fs_interface -> lem_support

}
#+END_SRC

#+RESULTS:
[[file:/tmp/tmp.png]]

* Actually do the compile (target: compile)

We construct the order of the calls to camlc manually; we add camlp4
only for those sources that require it. The following means we
recompile all ml files anytime any ml file changes, so the build is
slightly slower than it should be. The advantage is that hopefully the
makefile is simpler (no dependencies).

#+BEGIN_SRC makefile
compile: cmo cmx fs_spec_lib.cma fs_spec_lib.cmxa

cmo: $(DOTML) $(DOTMLI)
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -syntax camlp4o -c abstract_string.mli
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -syntax camlp4o -c lem_support.mli
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -syntax camlp4o -c fs_interface.mli
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -c list_array.mli
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -c fs_prelude.mli
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -syntax camlp4o -c fs_spec.ml
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -syntax camlp4o -c dir_heap.ml
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -c fs_dict_wrappers.mli
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -syntax camlp4o -package sha -c fs_dump.ml
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -c fs_printer.ml
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -syntax camlp4o -c fs_interface.mli
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -syntax camlp4o -c abstract_string.ml
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -c list_array.ml
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -syntax camlp4o -c lem_support.ml
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -c fs_prelude.ml
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -c fs_dict_wrappers.ml
	$(CAMLC) $(CAMLCINCLUDES) $(COMPFLAGS) -c fs_interface.ml
	touch cmo

cmx: $(DOTML) $(DOTMLI)
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -syntax camlp4o -c abstract_string.mli
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -syntax camlp4o -c lem_support.mli
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -syntax camlp4o -c fs_interface.mli
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -c list_array.mli
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -c fs_prelude.mli
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -syntax camlp4o -c fs_spec.ml
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -syntax camlp4o -c dir_heap.ml
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -c fs_dict_wrappers.mli
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -syntax camlp4o -package sha -c fs_dump.ml
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -c fs_printer.ml
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -syntax camlp4o -c fs_interface.mli
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -syntax camlp4o -c abstract_string.ml
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -c list_array.ml
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -syntax camlp4o -c lem_support.ml
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -c fs_prelude.ml
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -c fs_dict_wrappers.ml
	$(CAMLOPT) $(CAMLOPTINCLUDES) $(COMPFLAGS) -c fs_interface.ml
	touch cmx

# -g flag turns on debugging info (e.g. for stacktrace)
fs_spec_lib.cma: $(CMO)
	$(CAMLC) -g -a -o $@ $(CMO)

fs_spec_lib.cmxa: $(CMO:.cmo=.cmx)
	$(CAMLOPT) -g -a -o $@ $(CMO:.cmo=.cmx)
#+END_SRC

* Interface only

The interface files have reduced dependencies. Thus, it is possible to
build fs_interface.cmi very simply.

#+BEGIN_SRC makefile
interface_only: generated_ml
	$(CAMLC) $(CAMLCINCLUDES) -package sexplib,sexplib.syntax -syntax camlp4o -c abstract_string.mli -c lem_support.mli fs_interface.mli
	touch $@
#+END_SRC

* Tarball of generated files (to avoid invoking lem and cppo)

The order matters: we want lem before t_xxx.ml before .ml so that,
when unpacking, make doesn't think that eg a .lem is newer than the
corresponding .ml

Note that we still need lem installed so that we can access
extract.cm[x]a.

#+BEGIN_SRC makefile

define generated_files

t_fs_spec_fs_command_properties.lem
t_dir_heap.lem
t_fs_spec.lem
t_fs_spec_properties_perms.lem

t_dir_heap.ml
t_fs_prelude.ml
t_fs_spec_fs_command_properties.ml
t_fs_spec.ml
t_fs_spec_properties.ml
t_fs_spec_properties_perms.ml
t_list_arrayAuxiliary.ml
t_list_array.ml

dir_heap.ml
fs_prelude.ml
fs_spec_fs_command_properties.ml
fs_spec.ml
fs_spec_properties.ml
fs_spec_properties_perms.ml
list_array.ml

endef

generated.tar: generated_ml FORCE
	$(file >files_in_tar,$(generated_files))
	tar cvf $@  --files-from files_in_tar

generated: FORCE
	tar --touch -xvf generated.tar

#+END_SRC



* Clean

#+BEGIN_SRC makefile
# FIXME tidy this
# NB don't delete generated.tar - this is part of the "source" and should be upto date
clean: FORCE
	rm -f $(GENERATED_LEM) $(GENERATED_TML) $(GENERATED_ML)
	rm -f *.cm[iox] *.a *.o *.cma *.cmxa
	rm -f link generated_lem run_lem generated_tml generated_ml cmo cmx interface_only files_in_tar
	find . -maxdepth 1 -type l -exec rm \{\} \;	
	rm -f depend.{dot,pdf} .depend.min
	rm -f $(patsubst %.lem, %Auxiliary.lem, $(DOTLEM))
	rm -f $(patsubst %.lem, %Auxiliary.ml, $(DOTLEM))
	rm -f $(patsubst %.lem, %Auxiliary.byte, $(DOTLEM))
	rm -f $(patsubst %.lem, %.html, $(DOTLEM))
	rm -f $(patsubst %.lem, %ml.md, $(DOTLEM))
	rm -f $(patsubst %.lem, %.md, $(DOTLEM))
	rm -f *Script.sml
	rm -f a.out
	rm -rf ocamldoc ocamldoc* depend.svg fs_spec.html fs_spec.ml.md # t_fs_spec.lem_cppo.{html,md}
	rm -f *.tmp

FORCE:

#+END_SRC

* Emacs local variables

Local variables:
indent-tabs-mode: 't
org-src-preserve-indentation: 't
End:
